### 순차적 (비구조적) 프로그래밍

> 정의한 기능의 흐름에 따라 순서대로 동작을 추가하며 프로그램을 완성하는 방식이다.

장점 : 흐름이 눈으로 보이기 때문에 매우 직관적이다.

단점 : 프로그램의 규모가 커지면 스파게티 코드를 초래할 수 있음

<br>

### 절차적 (구조적) 프로그래밍

> 순차적 프로그래밍의 단점을 보완하기 위해서 등작한 것이 절차적 프로그래밍이다.
> 여기서 절차는 ‘함수’를 의미하며 반복되는 동작을 함수 및 프로시저(리턴값이 없는 함수) 형태로 모듈화하여 사용하는 방식이다.

장점 : 반복 동작을 모듈화하여 코드를 줄일 수 있다.

단점 : 프로시저 자체가 추상적이다.

예를 들어 도서관의 도서 관리 프로그램을 개발한다고 할때

1. ‘책’이라는 `자료형`을 구현 해야한다.
2. ‘책'에 대한 `함수`를 구현 해야한다.

하지만 절차적 프로그래밍에서는 책에 대한 자료형과 책에 대한 함수가 따로 있기 때문에 이 둘의 연관 여부를 논리 적으로 알아차리기 어렵다.

<br>

### 객체지향 프로그래밍

자료형과 함수를 묶기 위해서 객체지향 프로그래밍이 등장하게 되었다.

> 어떤 개념에 대한 자료형과 함수를 '객체' 형태로 함께 묶어서 관리하기 위해 프로그래밍 패러다임이다. 

위의 예시인 ‘도서관리 프로그램’도 객체지향으로 구현하게 되면 책의 제목, 저자, 페이지와 같은 자료형 필드와

대출하기, 반납하기 등의 메소드를 ‘책’이라는 객체에 묶어서 관리할 수 있다.

이렇게 되면 객체간의 독립성이 뚜렷하게 생기고 중복되는 코드의 양이 줄어들며 결과적으로 유지보수에 용이해진다.

<br>

### 객체지향 프로그래밍의 4가지 특징

1. 추상화 (Abstraction)
2. 캡슐화 (Encapsulation)
3. 상속
4. 다형성 (Polymorphism)

<br>

1. 추상화 (Abstraction)

객체들이 공통적으로 필요로 하는 속성이나 동작을 하나로 추출해내는 작업이다. (구체화의 반대라고 생각하자)

‘조류’라는 추상화 집합을 만들고 부리, 날개, 난다 등 조류가 가진 공통적인 특징을 만들어 활용하면 된다.

<br>

2. 캡슐화 (Encapsulation)

정보 은닉화를 통해 높은 응집도, 낮은 결합도를 유지할 수 있도록 설계하는 것이다.

쉽게 말하면, 한 곳에서 변화가 일어나도 다른 곳에 미치는 사이드 이펙트를 최소화
시키는 것을 의미한다. 즉, 객체 내부의 어떤 동작에 대한 구현이 어떻게 되어있는지 감추는 것
이다. 이를 통해 외부에서 뭔가 잘못 건드려 객체를 손상시키는 일을 방지할 수 있다.

따라서 독립적으로 만들어진 객체들 간의 의존도가 최대한 낮게 만드는 것이 중요
하다.

<br>

3. 상속

여러 객체들이 지닌 공통된 특성을 부각시켜 하나의 법칙으로 성립하는 과정으로

자식 클래스가 부모 클래스의 필드나 메소드를 그대로 물려받아 사용할 수 있게, 혹은 조금 다듬어서 사용할 수 있게 해주는 것이다.

<br>

4. 다형성 (Polymorphism)

서로 다른 클래스의 객체가 같은 동작 수행 명령을 받았을 때, 각자의 특성에 맞는 방식으로 동작하는 것이다.

즉 부모 클래스에서 정의된 메소드의 작업이 자식 클래스에서 다른것으로 대체될 수 있도록 한다.

객체지향 패러다임에서는 상속을 통해 공통된 코드를 간결하게 해주고 다형성을 통해 유연함을 갖춘다.

앞서 ‘조류’라는 객체에 날개, 부리, 난다 등의 공통적인 특성을 참새, 비둘기, 독수리 에게 상속했다면 ‘각 새들의 울음소리 재생’ 이라는 매소드를 실행했을 때, 자식클래스들이 각기 다른 울음소리를 내는 것은 다형성이 부각된 부분이다.

참고자료 : https://velog.io/@haero_kim/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
