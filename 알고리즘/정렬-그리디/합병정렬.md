직관적이지는 않지만 더 빠른 정렬 방법

버블,선택,삽입정렬 → 규모가 큰 곳에서 정렬하기 좋은 방법들이 아니다

## 합병정렬

- 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이나 알고리즘을 뜻한다.
- 분할 정복 알고리즘은 보통 재귀를 통해 구현된다.

0개 요소, 1개 요소 배열이 이미 정렬되어 있다는 점을 활용함

→ 더 큰 배열을 나누고 더 작은 하위 배열로 정렬

정렬된 배열, 0개나 1개 요소가 있는 배열이 될 때까지 분할하는 것이 포함되어 있음

1. 분할 : 정렬되지 않은 배열을 **절반**으로 잘라 비슷한 크기의 **두 배열로 나눈다**.
2. 정복 : 각 부분 배열을 **재귀**적으로 **합병 정렬**을 이용해 정렬한다.
3. 결합 : 두 부분 배열을 다시 하나의 정렬된 배열로 **합병**한다. 이때, 정렬 결과는 임시배열에 저장된다.
4. 복사 : 임시 배열에 저장된 결과를 원래 배열에 복사한다.

## 배열합병

- arr1과 arr2의 인덱스0부터 하나씩 비교 → 100과 1을 비교
- 1이 더 작기 때문에 1을 results라는 빈배열에 push

```jsx
// Merges two already sorted arrays
function merge(arr1, arr2){
    let results = [];
    let i = 0;
    let j = 0;
    while(i < arr1.length && j < arr2.length){ // i와 j가 배열의 길이 보다 짧을때(길이5까지)
        if(arr2[j] > arr1[i]){
            results.push(arr1[i]); 
            i++;
        } else {
            results.push(arr2[j])
            j++;
        } // 둘중에 작은 값을 빈배열에 push
    }
    while(i < arr1.length) { // 길이 7까지 100과 200이 담길 수 있도록 해줘야함
        results.push(arr1[i]) // arr1의 100 200을 넣어줌
        i++;
    }
    while(j < arr2.length) { 
        results.push(arr2[j])
        j++;
    }
    return results;
}
merge([100,200], [1,2,3,5,6])
```

아래의 두 while문을 적어주지 않을 경우 다음과 같이 [1,2,3,5,6]만 출력된다.

```jsx
// Merges two already sorted arrays
function merge(arr1, arr2){
    let results = [];
    let i = 0;
    let j = 0;
    while(i < arr1.length && j < arr2.length){ 
        if(arr2[j] > arr1[i]){
            results.push(arr1[i]); 
            i++;
        } else {
            results.push(arr2[j])
            j++;
        } 
    }
   
    return results; // [1,2,3,5,6]
}
merge([100,200], [1,2,3,5,6])
```

## 시간복잡도

합병 정렬에서는 최적케이스, 평균 케이스 가장 나쁜 케이스가 모두 O(nlogn)으로 같다.

버블 정렬의 경우 이미 정렬된 경우가 아니라면 O(n2)만큼 시간이 걸린다. 최적의 경우는 o(n)이 걸리지만 합병 정렬에서는 예외 케이스가 없다.

입력값이 무엇이든 중요하지 않다.

32

16 16

8 8 8 8

4 4 4 4 4 4 4 4

2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2

…

밑이 2인 logn의 의미는 2의 거듭제곱이 n을 나타낸다는 것이다.

배열에서 n 길이가 늘어나면 logn의 비율로 분할 횟수도 늘어난다.

그렇다면 nlogn은?

각 분할마다 합병할 때, O(n)번 비교한다.

왜냐하면 배열이 여러개로 쪼개졌을 뿐 값이 사라지거나 추가된 것이 아니기 때문이다.

따라서 n의 길이가 늘어난다면, 합병 정렬이 아닌 합병 알고리즘 자체는 O(n)의 시간 복잡도를 가지게 된다.

즉, O(nlogn)은 배열이 늘어나면 logn 비율로 늘어나며 매번 분할 할때마다 합병을 수행하려면 O(n)의 비교가 필요하다는 뜻이다.

## 공간 복잡도

공간 복잡도가 일정한 버블 정렬과는 차이가 보인다.

배열이 클수록 합병 정렬에서는 메모리에 더 많은 배열을 저장해야한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/75048675-7c59-4200-a474-66023a6f5434/Untitled.png)
